# 1. OSI 7层模型（TCP 4层）
## 每层协议
OSI七层模型是一种框架性的设计方法，设计的主要目的是为了解决**异种网络互联**时遇到的兼容问题，主要功能就是帮助不同类型的主机实现数据传输。最大优点是将***服务，协议，接口***三者明确的区分开来，通过七个层次化的结构模型使得不同的主机不同的网络之间实现可靠的通讯。**服务**说明下一层为上一层提供什么功能，**接口**说明上一层如何实现下一层提供的服务，**协议**涉及本层如何实现自己的服务

- 应用层 (Application)
	
		网络服务与最终用户的一个接口，
		协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP- 表示层（Presentation Layer）		数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）		格式有，JPEG、ASCll、DECOIC、加密格式等- 会话层（Session Layer）		建立、管理、终止会话。（在五层模型里面已经合并到了应用层）
		对应主机进程，指本地主机与远程主机正在进行的会话- 传输层 (Transport)		定义传输数据的协议端口号，以及流控和差错校验。		协议有：TCP UDP，数据包一旦离开网卡即进入网络传输层
		
	- **传输控制协议TCP：**提供面向连接的、可靠地数据传输服务，其数据传输的单位是报文段。
	- **用户数据报协议UDP：**提供无连接的、尽最大努力交付的数据传输服务（不保证数据传输的可靠性），其数据传输的单位是用户数据报。
		- 网络层 (Network)		
		进行逻辑地址寻址，实现不同网络之间的路径选择。		协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP
		
	在发送数据的时候，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。分组也叫**IP数据包**或者**数据报**。所以，网络层也是把数据封装成数据报。
	- 数据链路层 (Link)		
		建立逻辑连接、进行硬件地址寻址、差错校验[2]  等功能。（由底层网络定义协议）		将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。
		
	当两个相邻节点之间传送数据时，数据链路层将网络层上交下来的IP数据报**组装成帧**。
	- 物理层（Physical Layer）		
		建立、维护、断开物理连接。（由底层网络定义协议）		
TCP/IP 层级模型结构（五层模型），应用层之间的协议通过逐级调用传输层（Transport layer）、网络层（Network Layer）和物理数据链路层（Physical Data Link）而可以实现应用层的应用程序通信互联。
## url到页面的过程，以及遇到的问题

	参考资料：http://www.cnblogs.com/engeng/articles/5943382.html

总体来说分为以下几个阶段：
- DNS解析
- TCP连接
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 连接结束

### DNS解析
在浏览器输入网址，例如www.baidu.com，这是方便记忆的网址，而我们真正需要的是百度服务器的IP地址，就需要做一个IP地址和网址的转换，这个过程就是**DNS解析**。

###### 解析过程
DNS解析是一个**递归查询**的过程。
首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。

	网址真正的解析过程为: . -> .com -> google.com. -> www.google.com.。

###### DNS优化
递归查询请求太多，耗时间。利用**DNS缓存**进行优化。
	
	DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 
		浏览器缓存，系统缓存（host），路由器缓存，ISP服务器缓存，
		根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。
		修改hosts文件翻墙原理：https://www.zhihu.com/question/19782572

DNS每次返回的IP地址并不是都一样，**DNS负载均衡**。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。
CDN（内容分发网络）就是DNS重定向技术。

### TCP链接

HTTP协议是使用TCP作为其传输层协议的，所以需要三次握手创建连接。
【TCP优化：流量控制、拥塞避免、慢启动  http://blog.jobbole.com/105205/ 】

**HTTPS**协议：本质上是HTTP + SSL（or TLS），在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。避免传输过程中被截取，由于HTTP报文是明文，会存在信息泄露的风险。

**HTTPS**过程：HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。加密、握手产生时延，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。

![](https://segmentfault.com/img/bVp65j?_=5943382)

### 发出HTTP请求

**前端工程师眼中的HTTP，它主要发生在客户端。**
发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: **请求行**, **请求报头**和**请求正文**。

######请求行
	格式如下:
	Method Request-URL HTTP-Version CRLF

	eg: GET index.html HTTP/1.1
	常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。

	## GET和POST有什么区别？ ##
	

######请求报头
	请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。
	PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。
	
请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。
	
######请求正文

当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。


### 服务器处理请求并返回HTTP报文
**后端工程师眼中的HTTP。**
后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。
它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。

HTTP响应报文也是由三部分组成: **状态码**, **响应报头**和**响应报文**。

###### 状态码
状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:

	1xx：指示信息–表示请求已接收，继续处理。
	2xx：成功–表示请求已被成功接收、理解、接受。
	3xx：重定向–要完成请求必须进行更进一步的操作。
	4xx：客户端错误–请求有语法错误或请求无法实现。
	5xx：服务器端错误–服务器未能实现合法的请求。
平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。

TODO：**HTTP缓存**

###### 响应报头
常见的响应报头字段有: Server, Connection...。

###### 响应报文
服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。


### 浏览器解析渲染页面

浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。

![](https://segmentfault.com/img/bVCZ1H?w=694&h=340&_=5943382)

首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树,等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。
	
	涉及到两个概念：reflow（回流）和repain（重绘）。
	· DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow
	· 当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain

### Web优化
就是要快！如何尽快的加载资源？
答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。

# 2. HTTP

## HTTP/HTTPS 1.0/1.1/2.0

###HTTP 1.0

在 HTTP/1.0 中,大多实现为每个请求/响应交换使用新的连接。

HTTP 1.0规定浏览器与服务器**只保持短暂的连接**，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

**But** 一个包含有许多图像的网页文件中并没有包含真正的图像数据内容，而只是指明了这些图像的URL地址。则需要再次连接，再次请求和相应，比较费时。

### HTTP 1.1

在 HTTP/1.1 中,一个连接可用于一次或多次请求/响应交换,保持持久连接。减少连接次数，由于服务器保持链接需要占用一定的资源，所以需要权衡。

**1、**
为了克服HTTP 1.0的这个缺陷，HTTP 1.1支持**持久连接**，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。

一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。

**2、**
HTTP 1.1还允许客户端**不用等待**上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。
通过Connection请求头：Keep Alive和Close来判定。

**3、**
HTTP 1.1还通过增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能。**支持Host请求头字段**，保证WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。

**4、**
HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。

**5、**
支持断点续传，目前的Web服务器绝大多数都采用了HTTP/1.1。

### HTTP 2.0

与HTTP1.0的区别在于：
- 2.0采用的是二进制格式而非文本格式
		解析起来更高效，错误更少。
- 2.0是完全的多路复用，非有序并阻塞的，只需要一个连接即可实现并行。
		1.1存在线端阻塞问题，一次提交一个请求效率高，多了会变慢。
		采用多路复用，很好地解决上面的问题，能同时处理多个消息的请求和相应，一个连接就能加载一个页面。
- 使用报头压缩，2.0降低了开销。
		一个网页往往有很多资源需要加载，每个请求都有1400字节的消息头，耗时。
- 2.0让服务请可以将响应主动“推送”到客户端缓存中。
		通过主动推送将会需要的内容，避免往返的延迟。

### HTTP 与 HTTPS 

http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。https是HTTP运行在**SSL/TLS之上，SSL/TLS**运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。

**SSL**(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，**TLS**）是为网络通信提供安全及数据完整性的一种安全协议。


## GET/POST 以及幂等性

### GET和POST的区别

GET - 从指定的资源请求数据。
		
	请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：
	/test/demo_form.asp?name1=value1&name2=value2

POST - 向指定的资源提交要被处理的数据

	请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：
	POST /test/demo_form.asp HTTP/1.1
	Host: w3schools.com
	name1=value1&name2=value2

区别：

	GET 请求可被缓存
	GET 请求保留在浏览器历史记录中
	GET 请求可被收藏为书签
	GET 请求不应在处理敏感数据时使用，数据在URL中对所有人都是可见的。
	GET 请求有长度限制
	
	POST 请求不会被缓存
	POST 请求不会保留在浏览器历史记录中
	POST 不能被收藏为书签
	POST 请求对数据长度没有要求
	POST 数据不会显示在 URL 中。

### Get是安全的、幂等的。
所谓**安全的**意味着该操作用于获取信息而非修改信息。
所谓**幂等的**意味着对同一URL的多个请求应该返回同样的结果。

**PS：**		
对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。

对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。		

### POST表示可能改变服务器上的资源的请求。

ost是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为"GET"。


## HTTP协议头相关

通常HTTP消息包括*客户机向服务器的请求消息*和*服务器向客户机的响应消息*。这两种类型的消息由一个**起始行**，一个或者多个**头域**，一个只是**头域结束的空行**和**可选的消息体**组成。

每个头域由一个域名，冒号（:）和域值三部分组成。域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。

### 通用头域

通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。

### 请求消息（请求头域）

Method Request-URI HTTP-Version CRLF
另外，请求头域允许客户端向服务器传递关于请求或者关于客户机的附加信息。

### 响应信息

　HTTP-Version Status-Code Reason-Phrase CRLF
	
   响应头域允许服务器传递不能放在状态行的附加信息，这些域主要描述服务器的信息和Request-URI进一步的信息。

## 网络攻击

### CSRF
CSRF（Cross-site request forgery），中文名称：跨站请求伪造。**攻击者盗用了你的身份，以你的名义发送恶意请求。** Web的隐式身份验证机制！Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。CSRF攻击的一般是由服务端解决。

###### 原理

![](http://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg)

###### 服务器防御 - 增加伪随机数

- **Cookie Hashing**：在表单里面增加Hash值，以认证这确实是用户发送的请求。然后在服务器端进行Hash值验证。
- **验证码**：常用的随机字符串验证。
- **Anti Token**：当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。

### XSS

XSS（cross-site scripting跨域脚本攻击）攻击是最常见的Web攻击，其重点是“跨域”和“客户端执行”。

###### 反射性xss
发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。

###### 存储型xss
存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。

		后端尽可能对提交数据做过滤，在场景需求而不过滤的情况下，前端就需要做些处理了。

###### DOM xss
DOM XSS和反射型XSS、存储型XSS的差别在于DOM XSS的代码并不需要服务器参与，触发XSS靠的是浏览器端的DOM解析，完全是客户端的事情。Wifi劫持。

		使用HTTPS，用密钥来保护。
		参考资料：http://www.cnblogs.com/lovesong/p/5199623.html

# TCP/IP

## 三次握手、四次挥手

## 拥塞控制（过程、阈值）

## 流量控制与滑动窗口

## TCP与UDP比较

## 子网划分

## DDos攻击

# (B)IO / NIO / AIO

## 三者原理，各个语言是怎么实现的

## Netty

## Linux内核select/poll/epoll

---

	参考资料：
	计算机网络相关问题：http://blog.csdn.net/u012286517/article/details/50373759